<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPT Image 1 Mask Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: -1px;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            background: linear-gradient(45deg, #f8f9ff, #e8eeff);
            margin-bottom: 30px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: linear-gradient(45deg, #f0f2ff, #e0e5ff);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: linear-gradient(45deg, #e8eeff, #d8ddff);
            transform: scale(1.02);
        }

        .upload-text {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 15px;
        }

        #fileInput {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .canvas-container {
            position: relative;
            display: none;
            margin: 30px 0;
            text-align: center;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        #originalImage, #maskCanvas {
            max-width: 100%;
            max-height: 500px;
            display: block;
        }

        #maskCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            background: transparent;
        }

        .controls {
            display: none;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            font-weight: 600;
            color: #333;
            min-width: 80px;
        }

        input[type="range"] {
            flex: 1;
            min-width: 150px;
        }

        input[type="color"] {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
        }

        .btn-success {
            background: linear-gradient(135deg, #51cf66, #69db7c);
        }

        .info {
            background: linear-gradient(135deg, #74c0fc, #91a7ff);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: left;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn-group {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>GPT Image 1 Mask Generator</h1>
        
        <div class="upload-area" onclick="document.getElementById('fileInput').click()">
            <div class="upload-text">Click to upload or drag & drop your image</div>
            <button class="btn">Choose Image</button>
            <input type="file" id="fileInput" accept="image/*">
        </div>

        <div class="canvas-container" id="canvasContainer">
            <img id="originalImage" alt="Original Image">
            <canvas id="maskCanvas"></canvas>
        </div>

        <div class="controls" id="controls">
            <div class="control-group">
                <label>Brush Size:</label>
                <input type="range" id="brushSize" min="5" max="50" value="20">
                <span id="brushSizeValue">20px</span>
            </div>
            
            <div class="control-group">
                <label>Opacity:</label>
                <input type="range" id="opacity" min="0.1" max="1" step="0.1" value="0.5">
                <span id="opacityValue">50%</span>
            </div>
            
            <div class="control-group">
                <label>Color:</label>
                <input type="color" id="brushColor" value="#ff0000">
            </div>

            <div class="btn-group">
                <button class="btn" onclick="toggleEraser()">Toggle Eraser</button>
                <button class="btn btn-secondary" onclick="clearMask()">Clear Mask</button>
                <button class="btn" onclick="fillBackground()">Fill All</button>
                <button class="btn btn-success" onclick="downloadMask()">Download Mask</button>
            </div>
        </div>

        <div class="controls" id="modeControls" style="display: block;">
            <div class="control-group">
                <label>API Mode:</label>
                <button class="btn" id="apiModeToggle" onclick="toggleAPIMode()">GPT Image 1 Mode</button>
                <span id="apiModeDescription">OpenAI GPT Image 1 compatible masks</span>
            </div>
        </div>

        <div class="info">
            <div id="gptImageModeInfo">
                <strong>GPT Image 1 Mode:</strong> Create masks compatible with OpenAI's GPT Image 1 API.
                <br><br>
                <strong>Important:</strong> The mask will be generated at the exact same dimensions as your original image to prevent API errors.
                <br><br>
                <strong>How to use:</strong> Draw over the areas/objects you want to EDIT or REPLACE. 
                The drawn areas will become transparent in the mask, allowing GPT Image 1 to modify those regions.
                <br><br>
                <strong>API Usage:</strong> Use the downloaded PNG mask with client.images.edit(model="gpt-image-1", image=your_image, mask=mask_file, prompt="your edit prompt")
                <br><br>
                <strong>Format:</strong> Transparent = Editable areas, White = Protected areas with alpha channel.
            </div>
            <div id="standardModeInfo" style="display: none;">
                <strong>Standard Mode:</strong> Traditional black & white masks.
                <br><br>
                <strong>Format:</strong> Black = Protected, White = Editable (no alpha channel).
            </div>
        </div>
    </div>

    <script>
        let canvas, ctx, img, isDrawing = false, isErasing = false;
        let lastX = 0, lastY = 0;
        let isGPTImageMode = true; // Default to GPT Image 1 mode

        // File upload handling
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.querySelector('.upload-area');
        const canvasContainer = document.getElementById('canvasContainer');
        const controls = document.getElementById('controls');

        // Drag and drop functionality
        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function() {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                loadImage(e.target.result);
            };
            reader.readAsDataURL(file);
        }

        function loadImage(src) {
            img = document.getElementById('originalImage');
            canvas = document.getElementById('maskCanvas');
            ctx = canvas.getContext('2d');

            img.onload = function() {
                canvasContainer.style.display = 'block';
                controls.style.display = 'block';

                // Wait for image to be fully rendered in the DOM
                setTimeout(() => {
                    // Use the actual natural dimensions of the image, not display size
                    const naturalWidth = img.naturalWidth;
                    const naturalHeight = img.naturalHeight;
                    
                    console.log(`Image natural size: ${naturalWidth}x${naturalHeight}`);
                    console.log(`Image display size: ${img.offsetWidth}x${img.offsetHeight}`);
                    
                    // Set canvas to match the natural image dimensions
                    canvas.width = naturalWidth;
                    canvas.height = naturalHeight;
                    
                    // Scale the canvas display to match the image display
                    const scaleX = img.offsetWidth / naturalWidth;
                    const scaleY = img.offsetHeight / naturalHeight;
                    
                    canvas.style.width = img.offsetWidth + 'px';
                    canvas.style.height = img.offsetHeight + 'px';
                    
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    // Store scale factors for drawing coordinate conversion
                    canvas.scaleX = scaleX;
                    canvas.scaleY = scaleY;
                    
                    setupDrawing();
                }, 100);
            };

            img.src = src;
        }

        function setupDrawing() {
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                // Convert display coordinates to actual canvas coordinates
                lastX = (touch.clientX - rect.left) / canvas.scaleX;
                lastY = (touch.clientY - rect.top) / canvas.scaleY;
                isDrawing = true;
            });

            canvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
                if (!isDrawing) return;
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                // Convert display coordinates to actual canvas coordinates
                const currentX = (touch.clientX - rect.left) / canvas.scaleX;
                const currentY = (touch.clientY - rect.top) / canvas.scaleY;
                
                drawLine(lastX, lastY, currentX, currentY);
                lastX = currentX;
                lastY = currentY;
            });

            canvas.addEventListener('touchend', function(e) {
                e.preventDefault();
                isDrawing = false;
            });

            document.getElementById('brushSize').addEventListener('input', updateBrushSize);
            document.getElementById('opacity').addEventListener('input', updateOpacity);
            updateBrushSize();
            updateOpacity();
        }

        function startDrawing(e) {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            // Convert display coordinates to actual canvas coordinates
            lastX = (e.clientX - rect.left) / canvas.scaleX;
            lastY = (e.clientY - rect.top) / canvas.scaleY;
        }

        function draw(e) {
            if (!isDrawing) return;
            
            const rect = canvas.getBoundingClientRect();
            // Convert display coordinates to actual canvas coordinates
            const currentX = (e.clientX - rect.left) / canvas.scaleX;
            const currentY = (e.clientY - rect.top) / canvas.scaleY;
            
            drawLine(lastX, lastY, currentX, currentY);
            
            lastX = currentX;
            lastY = currentY;
        }

        function drawLine(x1, y1, x2, y2) {
            const brushSize = document.getElementById('brushSize').value;
            const opacity = document.getElementById('opacity').value;
            const color = document.getElementById('brushColor').value;

            // Scale brush size to match canvas resolution
            const scaledBrushSize = brushSize / Math.min(canvas.scaleX, canvas.scaleY);
            ctx.lineWidth = scaledBrushSize;
            
            if (isErasing) {
                ctx.globalCompositeOperation = 'destination-out';
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = hexToRgba(color, opacity);
            }

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function toggleEraser() {
            isErasing = !isErasing;
            canvas.style.cursor = isErasing ? 'grab' : 'crosshair';
            
            const btn = event.target;
            btn.textContent = isErasing ? 'Drawing Mode' : 'Toggle Eraser';
            btn.style.background = isErasing ? 
                'linear-gradient(135deg, #ff6b6b, #ff8e8e)' : 
                'linear-gradient(135deg, #667eea, #764ba2)';
        }

        function clearMask() {
            if (confirm('Are you sure you want to clear the mask?')) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        function toggleAPIMode() {
            isGPTImageMode = !isGPTImageMode;
            const apiModeToggle = document.getElementById('apiModeToggle');
            const apiModeDescription = document.getElementById('apiModeDescription');
            const gptImageInfo = document.getElementById('gptImageModeInfo');
            const standardInfo = document.getElementById('standardModeInfo');
            
            if (isGPTImageMode) {
                apiModeToggle.textContent = 'GPT Image 1 Mode';
                apiModeToggle.style.background = 'linear-gradient(135deg, #00D4AA, #00B894)';
                apiModeDescription.textContent = 'OpenAI GPT Image 1 compatible masks';
                gptImageInfo.style.display = 'block';
                standardInfo.style.display = 'none';
            } else {
                apiModeToggle.textContent = 'Standard Mode';
                apiModeToggle.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                apiModeDescription.textContent = 'Traditional black & white masks';
                gptImageInfo.style.display = 'none';
                standardInfo.style.display = 'block';
            }
        }

        function fillBackground() {
            const brushColor = document.getElementById('brushColor').value;
            const opacity = document.getElementById('opacity').value;
            
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = hexToRgba(brushColor, opacity);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function downloadMask() {
            const downloadCanvas = document.createElement('canvas');
            const downloadCtx = downloadCanvas.getContext('2d');
            
            downloadCanvas.width = canvas.width;
            downloadCanvas.height = canvas.height;
            
            if (isGPTImageMode) {
                // GPT Image 1 mode: Create mask with alpha channel
                // Drawn areas = transparent (editable), undrawn = white (protected)
                
                // Start with white background
                downloadCtx.fillStyle = 'white';
                downloadCtx.fillRect(0, 0, downloadCanvas.width, downloadCanvas.height);
                
                // Get the original canvas data
                const originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const originalData = originalImageData.data;
                
                // Create new image data with alpha channel
                const maskImageData = downloadCtx.createImageData(downloadCanvas.width, downloadCanvas.height);
                const maskData = maskImageData.data;
                
                // Process each pixel
                for (let i = 0; i < originalData.length; i += 4) {
                    if (originalData[i + 3] > 0) { // If pixel was drawn (editable area)
                        maskData[i] = 255;     // White
                        maskData[i + 1] = 255;
                        maskData[i + 2] = 255;
                        maskData[i + 3] = 0;   // Transparent (this is key for GPT Image 1)
                    } else { // Undrawn area (protected)
                        maskData[i] = 255;     // White
                        maskData[i + 1] = 255;
                        maskData[i + 2] = 255;
                        maskData[i + 3] = 255; // Opaque (protected)
                    }
                }
                
                downloadCtx.putImageData(maskImageData, 0, 0);
                
            } else {
                // Standard mode: Traditional black & white masks
                // Start with white background
                downloadCtx.fillStyle = 'white';
                downloadCtx.fillRect(0, 0, downloadCanvas.width, downloadCanvas.height);
                
                const originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const originalData = originalImageData.data;
                
                const maskImageData = downloadCtx.createImageData(downloadCanvas.width, downloadCanvas.height);
                const maskData = maskImageData.data;
                
                for (let i = 0; i < originalData.length; i += 4) {
                    if (originalData[i + 3] > 0) { // Drawn area = black (protected)
                        maskData[i] = 0;
                        maskData[i + 1] = 0;
                        maskData[i + 2] = 0;
                        maskData[i + 3] = 255;
                    } else { // Undrawn area = white (editable)
                        maskData[i] = 255;
                        maskData[i + 1] = 255;
                        maskData[i + 2] = 255;
                        maskData[i + 3] = 255;
                    }
                }
                
                downloadCtx.putImageData(maskImageData, 0, 0);
            }
            
            const fileName = isGPTImageMode ? 'gpt-image-mask.png' : 'standard-mask.png';
            
            downloadCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/png'); // Always PNG to preserve alpha channel
        }

        function updateBrushSize() {
            const value = document.getElementById('brushSize').value;
            document.getElementById('brushSizeValue').textContent = value + 'px';
        }

        function updateOpacity() {
            const value = document.getElementById('opacity').value;
            document.getElementById('opacityValue').textContent = Math.round(value * 100) + '%';
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
        }
    </script>
</body>
</html>